// This program looks for the //go:generate do magic directive on any struct in a directory tree
// and prints the names of the structs that have the directive

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"strings"
)

func main() {
	// Get the root directory as the first argument
	if len(os.Args) < 2 {
		fmt.Println("Usage: go run main.go <root_dir>")
		os.Exit(1)
	}
	root := os.Args[1]

	// Walk the directory tree and parse the Go files
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip non-Go files and directories
		if info.IsDir() || !strings.HasSuffix(path, ".go") {
			return nil
		}

		// Parse the Go file
		fset := token.NewFileSet()
		file, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return err
		}

		// Find the structs that have the //go:generate do magic directive
		findStructs(fset, file)

		return nil
	})

	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

// findStructs finds the structs that have the //go:generate do magic directive in a given file
func findStructs(fset *token.FileSet, file *ast.File) {
	// Iterate over the declarations in the file
	for _, decl := range file.Decls {
		// Check if the declaration is a type declaration
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		// for _, spec := range genDecl.Specs {
		// 	typeSpec, ok := spec.(*ast.TypeSpec)
		// 	if !ok || typeSpec.Doc == nil {
		// 		continue
		// 	}
		//
		// 	for _, docItem := range typeSpec.Doc.List {
		// 		if !strings.Contains(docItem.Text, "//templ:component-opts") {
		// 			continue
		// 		}
		//
		// 		// GENERATE OPTIONS BOILERPLATE
		// 		fmt.Printf("AAAAA: %v || %s || %s\n", docItem.Text, typeSpec.Name, file.)
		// 	}
		// }
		//
		// // Check if the declaration has a comment
		// if genDecl.Doc == nil {
		// 	continue
		// }

		// // Check if the comment contains the //go:generate do magic directive
		// if !strings.Contains(genDecl.Doc.Text(), "//templ:component-opts") {
		// 	continue
		// }

		// Iterate over the specs in the declaration
		for _, spec := range genDecl.Specs {
			// Check if the spec is a type spec
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok || typeSpec.Doc == nil {
				continue
			}

			var hasDirective bool
			for _, docItem := range typeSpec.Doc.List {
				if !strings.Contains(docItem.Text, "//templ:component-opts") {
					continue
				}

				hasDirective = true
				break
			}

			if !hasDirective {
				continue
			}

			// Check if the type is a struct type
			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			structName := typeSpec.Name.Name

			// Print the name and position of the struct
			// fmt.Printf("Found struct %s at %s\n", structName, fset.Position(structType.Pos()))

			if structType.Fields == nil || len(structType.Fields.List) == 0 {
				fmt.Println("no fields!!")
				continue
			}

			genFuncs(fset, file, structName, structType.Fields.List)
		}
	}
}

// genFuncs generates functions for each field in the struct
func genFuncs(fset *token.FileSet, file *ast.File, structName string, fields []*ast.Field) {
	// Create a new file to hold the generated functions
	// out, err := os.Create("gen_button.go")
	// if err != nil {
	// 	fmt.Println(err)
	// 	os.Exit(1)
	// }
	// defer out.Close()

	out := os.Stdout

	// Write the header
	fmt.Fprintln(out, "// Code generated by go generate; DO NOT EDIT.")
	fmt.Fprintln(out, "package", file.Name.Name)
	fmt.Fprintln(out, "")

	// Write the imports
	fmt.Fprintln(out, "import (")
	for _, imp := range file.Imports {
		fmt.Fprintln(out, imp.Path.Value)
	}
	fmt.Fprintln(out, ")")
	fmt.Fprintln(out, "")

	// Iterate over the fields
	for _, field := range fields {
		// Check if the field has a name
		if len(field.Names) == 0 {
			continue
		}

		// Get the field name and type
		fieldName := field.Names[0].Name
		fieldType := field.Type

		// Generate a function for the field
		genFunc(fset, out, structName, fieldName, fieldType)
	}

	genPrelude(fset, out, structName, fields)
}

func genPrelude(fset *token.FileSet, out *os.File, structName string, fields []*ast.Field) {
	// define a new Opt type that is simply a function which takes a pointer to the struct
	optType := &ast.TypeSpec{
		Name: ast.NewIdent("Opt"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						// input parameter that is a pointer to the struct
						Type: &ast.StarExpr{
							X: ast.NewIdent(structName),
						},
					},
				},
			},
		},
	}

	// declare the new Opt type
	optDecl := &ast.GenDecl{
		Tok:   token.TYPE,
		Specs: []ast.Spec{optType},
	}

	printer.Fprint(out, fset, optDecl)
	fmt.Fprintln(out, "")

	var defaults []ast.Expr
	for _, field := range fields {
		fieldName := field.Names[0].Name
		if field.Tag == nil {
			continue
		}

		tagValue := field.Tag.Value
		tag := reflect.StructTag(tagValue[1 : len(tagValue)-1]) // remove quotes

		defValue := tag.Get("default")
		fieldIdent, ok := field.Type.(*ast.Ident)
		if !ok {
			continue
		}

		switch fieldIdent.Name {
		case "string":
			defValue = fmt.Sprintf("%q", defValue)
		}

		defaults = append(defaults, &ast.KeyValueExpr{
			Key: ast.NewIdent(fieldName),
			Value: &ast.BasicLit{
				Kind:  field.Tag.Kind,
				Value: defValue,
			},
		})
	}

	// generate a new function to build a struct with a series of options
	withDecl := &ast.FuncDecl{
		Name: ast.NewIdent("With"),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{ast.NewIdent("opts")},
						Type: &ast.Ellipsis{
							Elt: ast.NewIdent("Opt"),
						},
					},
				},
			},

			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.StarExpr{
							X: ast.NewIdent(structName),
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{ast.NewIdent("out")},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.UnaryExpr{
							Op: token.AND,
							X: &ast.CompositeLit{
								Type: ast.NewIdent(structName),
								Elts: defaults,
							},
						},
					},
				},
				&ast.ExprStmt{
					// Create the call expression node
					X: &ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("out"),
							Sel: ast.NewIdent("With"),
						},
						Args: []ast.Expr{
							ast.NewIdent("opts"),
						},
						Ellipsis: 1,
					},
				},
				&ast.ReturnStmt{
					Results: []ast.Expr{ast.NewIdent("out")},
				},
			},
		},
	}

	printer.Fprint(out, fset, withDecl)
	fmt.Fprintln(out, "")
}

func genFunc(fset *token.FileSet, out *os.File, structName, fieldName string, fieldType ast.Expr) {
	// Create the function signature
	funcSig := &ast.FuncType{
		Params: &ast.FieldList{
			List: []*ast.Field{
				{
					// receive an input parameter called "in"
					Names: []*ast.Ident{ast.NewIdent("in")},
					Type:  fieldType,
				},
			},
		},
		Results: &ast.FieldList{
			List: []*ast.Field{
				{
					// return an Opt
					Type: ast.NewIdent("Opt"),
				},
			},
		},
	}

	retFunc := &ast.FuncType{
		Params: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("opts")},
					Type: &ast.StarExpr{
						X: ast.NewIdent(structName),
					},
				},
			},
		},
	}

	// Create the function body
	funcBody := &ast.BlockStmt{
		List: []ast.Stmt{
			// Create a new component
			&ast.AssignStmt{
				Lhs: []ast.Expr{ast.NewIdent("opts." + fieldName)},
				Tok: token.ASSIGN,
				Rhs: []ast.Expr{ast.NewIdent("in")},
			},
		},
	}

	closure := &ast.FuncLit{
		Type: retFunc,
		Body: funcBody,
	}

	// Create the function declaration
	funcDecl := &ast.FuncDecl{
		Name: ast.NewIdent(fieldName),
		Type: funcSig,
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{closure},
				},
			},
		},
	}

	// Write the function declaration to the file
	printer.Fprint(out, fset, funcDecl)
	fmt.Fprintln(out, "")
}
